\subsubsection{Класс узла дерева поиска \texttt{Node}}


Класс \texttt{Node} является простейшим узлом дерефа Хаффмана.
Сначала из этих узлов составляется очередь, потом по этой очереди строится само дерево.
Рассмотрим основные поля и методы данного класса.



\texttt{Ptr left, right и parent}.
Для предотвращения утечек памяти в данном классе используются умные указатели на узлы листьев (левый и правый потомок) и родителя.
Так как для построения дерева нам понадобится изменять указатели или использовать несколько указателей на один объект, то для таких случаев подходит тип \texttt{std::shared{\textunderscore}ptr<Node>}.
Данный тип указателя отслеживает свое время жизни и количество ссылок указывающих на него.
При выходе из всех блоков кода или удалении всех ссылок, для объекта \texttt{std::shared{\textunderscore}ptr}\cite{cpp} вызывается деструктор и память, выделенная ранее для объекта класса, освобождается.
Для чистоты и упрощения кода тип данных этих трех полей является пользовательским: \texttt{typedef std::shared{\textunderscore}ptr<Node> ptr}.



Эти три поля публичные, для возможности прохода по дереву.
Все остальные поля класса \texttt{Node} являются приватными\cite{lucik} для защиты данных от внешних изменений из других функций и классов.



\texttt{Unsigned char ch}. 
Данное поле хранит в себе байт данных (символ в случае текстовых файлов).



\texttt{Int frequency}.
В этой переменной хранится количество повторений переменной \texttt{ch} в заданном объеме данных.



\texttt{Std::string code{\textunderscore}string}. 
Здесь хранится уже окончательная кодировка символа, которая будет записана в сжатый файл.



\texttt{Std::string name} не является обязательным атрибутом класса, но его удобно использовать при логировании работы программы чтобы проверить правильность выполнения алгоритма.
Имеет то же значение что и \texttt{ch}, но в другом типе данных.



\texttt{Node(), Node(unsigned char uch, int f)} и \texttt{Node(const std::string\& n, int f)}.
Для всех возможных входных данных существует несколько конструкторов: нулевой (поля класса не заполняются), с входным символом и его частотой, с входной строкой (состоящей из одного символа) и количеством ее вхождений.



\texttt{Bool operator < (const Node\& oth)}.
Этот метод предназначен для сравнения частот двух узлов и последующего построения бинарного дерева.



\texttt{Std::string get{\textunderscore}name()} и \texttt{std::ostream\& operator << (std::ostream \&out, Node node)}.
Данная функция и дружественная прегрузка оператора ввода предназначены как и поле \texttt{std::string name} для логирования алгоритма.
Они позволяют просмотреть какие значения хранит дерево и сверить итоговую таблицу кодирования.



\texttt{Std::string code()}, \texttt{unsigned char get{\textunderscore}byte()} и \texttt{int get{\textunderscore}frequency()}.
Эти методы предназначены для возвращения значений соответствующих атрибутов узла -- \texttt{std::string code{\textunderscore}string}, \texttt{ch} и \texttt{frequency}.



\texttt{Void set{\textunderscore}frequency(int f)} и \texttt{void code(const std::string\& c)}.
Данные методы нужны для присваивания значения одноименным переменным (полю \texttt{ch}значения присваивается только в конструкторе).
Функция изменения атрибута \texttt{frequency} обязательна из-за правила построения дерева Хаффмана, суть которого состоит в присвоении частоте родителя суммы частот его листьев\cite{wiki_huf}.


Из-за использования умных указателей, необходимость в использовании деструктора отсутсвует.